# ULTIMATE INSTITUTIONAL FAST FVG STRATEGY - REMOVED ALL OTHER STRATEGIES

import os
import time
import requests
import pandas as pd
import yfinance as yf
import ta
import warnings
import pyotp
import math
from datetime import datetime, time as dtime, timedelta
from SmartApi.smartConnect import SmartConnect
import threading
import numpy as np

warnings.filterwarnings("ignore")

# ---------------- INSTITUTIONAL CONFIG ----------------
OPENING_PLAY_ENABLED = True
OPENING_START = dtime(9,15)
OPENING_END = dtime(9,45)

# INSTITUTIONAL FVG PARAMETERS
INSTITUTIONAL_FVG_GAP_THRESHOLD = 0.0035  # Increased for faster moves
INSTITUTIONAL_FVG_CONFIRMATION_VOLUME = 2.0
INSTITUTIONAL_FVG_MOMENTUM_FACTOR = 1.8
INSTITUTIONAL_FVG_TARGET_MULTIPLIER = 0.006  # 0.6% quick targets
INSTITUTIONAL_FVG_SL_MULTIPLIER = 0.002     # Tight SL for quick exits

# LIQUIDITY ZONE PARAMETERS
LIQUIDITY_SWEEP_DISTANCE = 0.004
LIQUIDITY_CONFIRMATION_VOLUME = 2.2

# --------- EXPIRIES FOR KEPT INDICES ---------
EXPIRIES = {
    "NIFTY": "18 NOV 2025",
    "BANKNIFTY": "25 NOV 2025", 
    "SENSEX": "20 NOV 2025"
}

# --------- SIMPLIFIED STRATEGY TRACKING ---------
STRATEGY_NAMES = {
    "institutional_fvg": "INSTITUTIONAL FVG",
    "liquidity_sweeps": "LIQUIDITY SWEEP"
}

# --------- ENHANCED TRACKING FOR REPORTS ---------
all_generated_signals = []
strategy_performance = {}
signal_counter = 0
daily_signals = []

# --------- SIGNAL DEDUPLICATION AND COOLDOWN TRACKING ---------
active_strikes = {}
last_signal_time = {}
signal_cooldown = 900  # 15 minutes cooldown for faster cycling

def initialize_strategy_tracking():
    """Initialize strategy performance tracking"""
    global strategy_performance
    strategy_performance = {
        "INSTITUTIONAL FVG": {"total": 0, "success_2_targets": 0, "success_3_4_targets": 0, "total_pnl": 0},
        "LIQUIDITY SWEEP": {"total": 0, "success_2_targets": 0, "success_3_4_targets": 0, "total_pnl": 0}
    }

# Initialize tracking
initialize_strategy_tracking()

# --------- ANGEL ONE LOGIN ---------
API_KEY = os.getenv("API_KEY")
CLIENT_CODE = os.getenv("CLIENT_CODE")
PASSWORD = os.getenv("PASSWORD")
TOTP_SECRET = os.getenv("TOTP_SECRET")
TOTP = pyotp.TOTP(TOTP_SECRET).now()

client = SmartConnect(api_key=API_KEY)
session = client.generateSession(CLIENT_CODE, PASSWORD, TOTP)
feedToken = client.getfeedToken()

# --------- TELEGRAM ---------
BOT_TOKEN = os.getenv("BOT_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")

STARTED_SENT = False
STOP_SENT = False
MARKET_CLOSED_SENT = False
EOD_REPORT_SENT = False

def send_telegram(msg, reply_to=None):
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        payload = {"chat_id": CHAT_ID, "text": msg}
        if reply_to:
            payload["reply_to_message_id"] = reply_to
        r = requests.post(url, data=payload, timeout=5).json()
        return r.get("result", {}).get("message_id")
    except:
        return None

# --------- MARKET HOURS ---------
def is_market_open():
    utc_now = datetime.utcnow()
    ist_now = utc_now + timedelta(hours=5, minutes=30)
    current_time_ist = ist_now.time()
    return dtime(9,15) <= current_time_ist <= dtime(15,30)

def should_stop_trading():
    utc_now = datetime.utcnow()
    ist_now = utc_now + timedelta(hours=5, minutes=30)
    current_time_ist = ist_now.time()
    return current_time_ist >= dtime(15,30)

# --------- STRIKE ROUNDING FOR KEPT INDICES ---------
def round_strike(index, price):
    try:
        if price is None:
            return None
        if isinstance(price, float) and math.isnan(price):
            return None
        price = float(price)
        
        if index == "NIFTY": 
            return int(round(price / 50.0) * 50)
        elif index == "BANKNIFTY": 
            return int(round(price / 100.0) * 100)
        elif index == "SENSEX": 
            return int(round(price / 100.0) * 100)
        else: 
            return int(round(price / 50.0) * 50)
    except Exception:
        return None

# --------- ENSURE SERIES ---------
def ensure_series(data):
    return data.iloc[:,0] if isinstance(data, pd.DataFrame) else data.squeeze()

# --------- FETCH INDEX DATA FOR KEPT INDICES ---------
def fetch_index_data(index, interval="5m", period="2d"):
    symbol_map = {
        "NIFTY": "^NSEI", 
        "BANKNIFTY": "^NSEBANK", 
        "SENSEX": "^BSESN"
    }
    df = yf.download(symbol_map[index], period=period, interval=interval, auto_adjust=True, progress=False)
    return None if df.empty else df

# --------- LOAD TOKEN MAP ---------
def load_token_map():
    try:
        url="https://margincalculator.angelbroking.com/OpenAPI_File/files/OpenAPIScripMaster.json"
        df=pd.DataFrame(requests.get(url,timeout=10).json())
        df.columns=[c.lower() for c in df.columns]
        df=df[df['exch_seg'].str.upper().isin(["NFO", "BFO"])]
        df['symbol']=df['symbol'].str.upper()
        return df.set_index('symbol')['token'].to_dict()
    except:
        return {}

token_map=load_token_map()

# --------- SAFE LTP FETCH ---------
def fetch_option_price(symbol, retries=3, delay=3):
    token=token_map.get(symbol.upper())
    if not token:
        return None
    for _ in range(retries):
        try:
            exchange = "BFO" if "SENSEX" in symbol.upper() else "NFO"
            data=client.ltpData(exchange, symbol, token)
            return float(data['data']['ltp'])
        except:
            time.sleep(delay)
    return None

# --------- INSTITUTIONAL LIQUIDITY HUNT ---------
def institutional_liquidity_hunt(index, df):
    prev_high = None
    prev_low = None
    try:
        prev_high_val = ensure_series(df['High']).iloc[-2]
        prev_low_val = ensure_series(df['Low']).iloc[-2]
        prev_high = float(prev_high_val) if not (isinstance(prev_high_val,float) and math.isnan(prev_high_val)) else None
        prev_low = float(prev_low_val) if not (isinstance(prev_low_val,float) and math.isnan(prev_low_val)) else None
    except Exception:
        prev_high = None
        prev_low = None

    high_zone, low_zone = detect_liquidity_zone(df, lookback=15)

    last_close_val = None
    try:
        lc = ensure_series(df['Close']).iloc[-1]
        if isinstance(lc, float) and math.isnan(lc):
            last_close_val = None
        else:
            last_close_val = float(lc)
    except Exception:
        last_close_val = None

    if last_close_val is None:
        highest_ce_oi_strike = None
        highest_pe_oi_strike = None
    else:
        highest_ce_oi_strike = round_strike(index, last_close_val + 50)
        highest_pe_oi_strike = round_strike(index, last_close_val - 50)

    bull_liquidity = []
    if prev_low is not None: bull_liquidity.append(prev_low)
    if low_zone is not None: bull_liquidity.append(low_zone)
    if highest_pe_oi_strike is not None: bull_liquidity.append(highest_pe_oi_strike)

    bear_liquidity = []
    if prev_high is not None: bear_liquidity.append(prev_high)
    if high_zone is not None: bear_liquidity.append(high_zone)
    if highest_ce_oi_strike is not None: bear_liquidity.append(highest_ce_oi_strike)

    return bull_liquidity, bear_liquidity

def detect_liquidity_zone(df, lookback=20):
    high_series = ensure_series(df['High']).dropna()
    low_series = ensure_series(df['Low']).dropna()
    try:
        if len(high_series) <= lookback:
            high_pool = float(high_series.max()) if len(high_series)>0 else float('nan')
        else:
            high_pool = float(high_series.rolling(lookback).max().iloc[-2])
    except Exception:
        high_pool = float(high_series.max()) if len(high_series)>0 else float('nan')
    try:
        if len(low_series) <= lookback:
            low_pool = float(low_series.min()) if len(low_series)>0 else float('nan')
        else:
            low_pool = float(low_series.rolling(lookback).min().iloc[-2])
    except Exception:
        low_pool = float(low_series.min()) if len(low_series)>0 else float('nan')

    if math.isnan(high_pool) and len(high_series)>0:
        high_pool = float(high_series.max())
    if math.isnan(low_pool) and len(low_series)>0:
        low_pool = float(low_series.min())

    return round(high_pool,0), round(low_pool,0)

# üö® ULTIMATE INSTITUTIONAL FVG STRATEGY üö®
def detect_institutional_fvg(df):
    """
    INSTITUTIONAL FVG DETECTION - FAST MOVING, QUICK TARGETS
    Pattern: Detects FVG BEFORE it fully forms for early entry
    """
    try:
        high = ensure_series(df['High'])
        low = ensure_series(df['Low'])
        close = ensure_series(df['Close'])
        volume = ensure_series(df['Volume'])
        
        if len(close) < 5:
            return None
            
        # Get current and previous candles
        current_high = high.iloc[-1]
        current_low = low.iloc[-1]
        current_close = close.iloc[-1]
        
        prev_high = high.iloc[-2]
        prev_low = low.iloc[-2]
        prev_close = close.iloc[-2]
        
        pre_prev_high = high.iloc[-3]
        pre_prev_low = low.iloc[-3]
        
        # Volume confirmation
        current_volume = volume.iloc[-1]
        avg_volume = volume.rolling(10).mean().iloc[-1]
        volume_ratio = current_volume / (avg_volume if avg_volume > 0 else 1)
        
        # üö® INSTITUTIONAL BULLISH FVG (Early Detection)
        # Pattern: Current low > Previous high + Gap threshold
        bullish_gap_condition = (
            current_low > prev_high * (1 + INSTITUTIONAL_FVG_GAP_THRESHOLD) and
            current_close > prev_close and
            volume_ratio > INSTITUTIONAL_FVG_CONFIRMATION_VOLUME and
            current_close > (prev_high + prev_low) / 2
        )
        
        # üö® INSTITUTIONAL BEARISH FVG (Early Detection)  
        # Pattern: Current high < Previous low - Gap threshold
        bearish_gap_condition = (
            current_high < prev_low * (1 - INSTITUTIONAL_FVG_GAP_THRESHOLD) and
            current_close < prev_close and
            volume_ratio > INSTITUTIONAL_FVG_CONFIRMATION_VOLUME and
            current_close < (prev_high + prev_low) / 2
        )
        
        # üö® MOMENTUM CONFIRMATION FOR FASTER MOVES
        if bullish_gap_condition:
            # Additional momentum check for faster bullish moves
            price_momentum = (current_close - prev_close) / prev_close
            if price_momentum > 0.001:  # Minimum 0.1% momentum
                return "CE"
                
        if bearish_gap_condition:
            # Additional momentum check for faster bearish moves
            price_momentum = (current_close - prev_close) / prev_close
            if price_momentum < -0.001:  # Minimum 0.1% momentum
                return "PE"
                
    except Exception as e:
        return None
    return None

# üö® ENHANCED LIQUIDITY SWEEP STRATEGY üö®
def detect_liquidity_sweeps(df):
    """
    INSTITUTIONAL LIQUIDITY SWEEP DETECTION
    Focus on fast moves after liquidity grabs
    """
    try:
        high = ensure_series(df['High'])
        low = ensure_series(df['Low'])
        close = ensure_series(df['Close'])
        volume = ensure_series(df['Volume'])
        
        if len(close) < 10:
            return None
            
        # Recent liquidity levels
        recent_highs = high.iloc[-10:-2]
        recent_lows = low.iloc[-10:-2]
        
        liquidity_high = recent_highs.max()
        liquidity_low = recent_lows.min()
        
        current_high = high.iloc[-1]
        current_low = low.iloc[-1]
        current_close = close.iloc[-1]
        
        # Volume confirmation for institutional moves
        current_volume = volume.iloc[-1]
        avg_volume = volume.iloc[-10:-1].mean()
        volume_ratio = current_volume / (avg_volume if avg_volume > 0 else 1)
        
        # üö® BEARISH LIQUIDITY SWEEP (Fast Move Down)
        # Pattern: Sweep above recent high then rejection
        if (current_high > liquidity_high * (1 + LIQUIDITY_SWEEP_DISTANCE) and
            current_close < liquidity_high * 0.998 and
            volume_ratio > LIQUIDITY_CONFIRMATION_VOLUME and
            current_close < close.iloc[-2]):  # Additional bearish confirmation
            return "PE"
            
        # üö® BULLISH LIQUIDITY SWEEP (Fast Move Up)  
        # Pattern: Sweep below recent low then rejection
        if (current_low < liquidity_low * (1 - LIQUIDITY_SWEEP_DISTANCE) and
            current_close > liquidity_low * 1.002 and
            volume_ratio > LIQUIDITY_CONFIRMATION_VOLUME and
            current_close > close.iloc[-2]):  # Additional bullish confirmation
            return "CE"
            
    except Exception:
        return None
    return None

# üö® INSTITUTIONAL MOMENTUM CONFIRMATION üö®
def institutional_momentum_confirmation(index, df, proposed_signal):
    """
    Final institutional confirmation for FAST moves
    """
    try:
        close = ensure_series(df['Close'])
        volume = ensure_series(df['Volume'])
        high = ensure_series(df['High'])
        low = ensure_series(df['Low'])
        
        if len(close) < 5:
            return False
            
        # Volume momentum confirmation
        current_volume = volume.iloc[-1]
        avg_volume = volume.rolling(10).mean().iloc[-1]
        volume_ratio = current_volume / (avg_volume if avg_volume > 0 else 1)
        
        if volume_ratio < 1.5:  # Require significant volume
            return False
            
        # Price momentum confirmation for FAST moves
        if proposed_signal == "CE":
            # For CE: require strong upward momentum
            price_change_1 = (close.iloc[-1] - close.iloc[-2]) / close.iloc[-2]
            price_change_2 = (close.iloc[-2] - close.iloc[-3]) / close.iloc[-3]
            if not (price_change_1 > 0.001 or price_change_2 > 0.001):
                return False
                
        elif proposed_signal == "PE":
            # For PE: require strong downward momentum
            price_change_1 = (close.iloc[-1] - close.iloc[-2]) / close.iloc[-2]
            price_change_2 = (close.iloc[-2] - close.iloc[-3]) / close.iloc[-3]
            if not (price_change_1 < -0.001 or price_change_2 < -0.001):
                return False
                
        return True
        
    except Exception:
        return False

# --------- SIGNAL DEDUPLICATION AND COOLDOWN CHECK ---------
def can_send_signal(index, strike, option_type):
    """Check if we can send signal based on deduplication and cooldown rules"""
    global active_strikes, last_signal_time
    
    current_time = time.time()
    strike_key = f"{index}_{strike}_{option_type}"
    
    # Check if same strike is already active
    if strike_key in active_strikes:
        return False
        
    # Check cooldown for this index
    if index in last_signal_time:
        time_since_last = current_time - last_signal_time[index]
        if time_since_last < signal_cooldown:
            return False
    
    return True

def update_signal_tracking(index, strike, option_type, signal_id):
    """Update tracking for sent signals"""
    global active_strikes, last_signal_time
    
    strike_key = f"{index}_{strike}_{option_type}"
    active_strikes[strike_key] = {
        'signal_id': signal_id,
        'timestamp': time.time(),
        'targets_hit': 0
    }
    
    last_signal_time[index] = time.time()

def update_signal_progress(signal_id, targets_hit):
    """Update progress of active signal"""
    for strike_key, data in active_strikes.items():
        if data['signal_id'] == signal_id:
            active_strikes[strike_key]['targets_hit'] = targets_hit
            break

def clear_completed_signal(signal_id):
    """Clear signal from active tracking when completed"""
    global active_strikes
    active_strikes = {k: v for k, v in active_strikes.items() if v['signal_id'] != signal_id}

# --------- UPDATED STRATEGY CHECK WITH ONLY FVG + LIQUIDITY ---------
def analyze_index_signal(index):
    df5 = fetch_index_data(index, "5m", "2d")
    if df5 is None:
        return None

    close5 = ensure_series(df5["Close"])
    if len(close5) < 10 or close5.isna().iloc[-1] or close5.isna().iloc[-2]:
        return None

    # üö® TIME-BASED FILTER - Avoid unreliable periods
    try:
        utc_now = datetime.utcnow()
        ist_now = utc_now + timedelta(hours=5, minutes=30)
        current_time = ist_now.time()
        # Avoid last 45 minutes and first 15 minutes for cleaner signals
        if current_time >= dtime(14, 45) or current_time <= dtime(9, 30):
            return None
    except:
        pass

    # üö® PRIORITY 1: INSTITUTIONAL FVG (FAST MOVING)
    fvg_signal = detect_institutional_fvg(df5)
    if fvg_signal:
        if institutional_momentum_confirmation(index, df5, fvg_signal):
            return fvg_signal, df5, False, "institutional_fvg"

    # üö® PRIORITY 2: LIQUIDITY SWEEPS
    liquidity_signal = detect_liquidity_sweeps(df5)
    if liquidity_signal:
        if institutional_momentum_confirmation(index, df5, liquidity_signal):
            return liquidity_signal, df5, True, "liquidity_sweeps"

    return None

# --------- FIXED: SYMBOL FORMAT FOR KEPT INDICES ---------
def get_option_symbol(index, expiry_str, strike, opttype):
    """FIXED: Each index uses its own isolated strike calculation"""
    dt = datetime.strptime(expiry_str, "%d %b %Y")
    
    if index == "SENSEX":
        year_short = dt.strftime("%y")
        month_code = dt.strftime("%b").upper()
        day = dt.strftime("%d")
        return f"SENSEX{year_short}{month_code}{strike}{opttype}"
    else:
        return f"{index}{dt.strftime('%d%b%y').upper()}{strike}{opttype}"

# --------- INSTITUTIONAL FLOW CONFIRMATION ---------
def institutional_flow_confirm(index, base_signal, df5):
    """
    Simplified institutional confirmation for FAST moves
    """
    try:
        close = ensure_series(df5['Close'])
        last_close = float(close.iloc[-1])
        
        # Basic liquidity zone check
        high_zone, low_zone = detect_liquidity_zone(df5, lookback=15)
        if base_signal == 'CE' and last_close >= high_zone:
            return False
        if base_signal == 'PE' and last_close <= low_zone:
            return False

        return True
    except Exception:
        return False

# --------- FIXED: ENHANCED TRADE MONITORING ---------
active_trades = {}

def calculate_pnl(entry, max_price, targets, targets_hit, sl):
    try:
        if targets is None or len(targets) == 0:
            diff = max_price - entry
            if diff > 0:
                return f"+{diff:.2f}"
            elif diff < 0:
                return f"-{abs(diff):.2f}"
            else:
                return "0"
        
        if not isinstance(targets_hit, (list, tuple)):
            targets_hit = list(targets_hit) if targets_hit is not None else [False]*len(targets)
        if len(targets_hit) < len(targets):
            targets_hit = list(targets_hit) + [False] * (len(targets) - len(targets_hit))
        
        achieved_prices = [target for i, target in enumerate(targets) if targets_hit[i]]
        if achieved_prices:
            exit_price = achieved_prices[-1]
            diff = exit_price - entry
            if diff > 0:
                return f"+{diff:.2f}"
            elif diff < 0:
                return f"-{abs(diff):.2f}"
            else:
                return "0"
        else:
            if max_price <= sl:
                diff = sl - entry
                if diff > 0:
                    return f"+{diff:.2f}"
                elif diff < 0:
                    return f"-{abs(diff):.2f}"
                else:
                    return "0"
            else:
                diff = max_price - entry
                if diff > 0:
                    return f"+{diff:.2f}"
                elif diff < 0:
                    return f"-{abs(diff):.2f}"
                else:
                    return "0"
    except Exception:
        return "0"

def monitor_price_live(symbol, entry, targets, sl, fakeout, thread_id, strategy_name, signal_data):
    def monitoring_thread():
        global daily_signals
        
        last_high = entry
        weakness_sent = False
        in_trade = False
        entry_price_achieved = False
        max_price_reached = entry
        targets_hit = [False] * len(targets)
        last_activity_time = time.time()
        signal_id = signal_data.get('signal_id')
        
        while True:
            current_time = time.time()
            
            # Check for inactivity (15 minutes for fast moves)
            if not in_trade and (current_time - last_activity_time) > 900:
                send_telegram(f"‚è∞ {symbol}: No activity for 15 minutes. Allowing new signals.", reply_to=thread_id)
                clear_completed_signal(signal_id)
                break
                
            if should_stop_trading():
                try:
                    final_pnl = calculate_pnl(entry, max_price_reached, targets, targets_hit, sl)
                except Exception:
                    final_pnl = "0"
                signal_data.update({
                    "entry_status": "NOT_ENTERED" if not entry_price_achieved else "ENTERED",
                    "targets_hit": sum(targets_hit),
                    "max_price_reached": max_price_reached,
                    "zero_targets": sum(targets_hit) == 0,
                    "no_new_highs": max_price_reached <= entry,
                    "final_pnl": final_pnl
                })
                daily_signals.append(signal_data)
                clear_completed_signal(signal_id)
                break
                
            price = fetch_option_price(symbol)
            if price:
                last_activity_time = current_time
                price = round(price)
                
                if price > max_price_reached:
                    max_price_reached = price
                
                if not in_trade:
                    if price >= entry:
                        send_telegram(f"‚úÖ ENTRY TRIGGERED at {price}", reply_to=thread_id)
                        in_trade = True
                        entry_price_achieved = True
                        last_high = price
                        signal_data["entry_status"] = "ENTERED"
                else:
                    if price > last_high:
                        send_telegram(f"üöÄ {symbol} making new high ‚Üí {price}", reply_to=thread_id)
                        last_high = price
                    elif not weakness_sent and price < sl * 1.05:
                        send_telegram(f"‚ö° {symbol} showing weakness near SL {sl}", reply_to=thread_id)
                        weakness_sent = True
                    
                    # Update signal progress
                    current_targets_hit = sum(targets_hit)
                    for i, target in enumerate(targets):
                        if price >= target and not targets_hit[i]:
                            send_telegram(f"üéØ {symbol}: Target {i+1} hit at ‚Çπ{target}", reply_to=thread_id)
                            targets_hit[i] = True
                            current_targets_hit = sum(targets_hit)
                            update_signal_progress(signal_id, current_targets_hit)
                    
                    # SL hit - allow immediate new signal
                    if price <= sl:
                        send_telegram(f"üîó {symbol}: Stop Loss {sl} hit. Exit trade. ALLOWING NEW SIGNAL.", reply_to=thread_id)
                        try:
                            final_pnl = calculate_pnl(entry, max_price_reached, targets, targets_hit, sl)
                        except Exception:
                            final_pnl = "0"
                        signal_data.update({
                            "targets_hit": sum(targets_hit),
                            "max_price_reached": max_price_reached,
                            "zero_targets": sum(targets_hit) == 0,
                            "no_new_highs": max_price_reached <= entry,
                            "final_pnl": final_pnl
                        })
                        daily_signals.append(signal_data)
                        clear_completed_signal(signal_id)
                        break
                        
                    # 2nd target hit - allow new signals but continue monitoring
                    if current_targets_hit >= 2:
                        update_signal_progress(signal_id, current_targets_hit)
                    
                    # All targets hit - complete trade
                    if all(targets_hit):
                        send_telegram(f"üèÜ {symbol}: ALL TARGETS HIT! Trade completed successfully!", reply_to=thread_id)
                        try:
                            final_pnl = calculate_pnl(entry, max_price_reached, targets, targets_hit, sl)
                        except Exception:
                            final_pnl = "0"
                        signal_data.update({
                            "targets_hit": len(targets),
                            "max_price_reached": max_price_reached,
                            "zero_targets": False,
                            "no_new_highs": False,
                            "final_pnl": final_pnl
                        })
                        daily_signals.append(signal_data)
                        clear_completed_signal(signal_id)
                        break
            
            time.sleep(10)
    
    thread = threading.Thread(target=monitoring_thread)
    thread.daemon = True
    thread.start()

# --------- FIXED: WORKING EOD REPORT SYSTEM ---------
def send_individual_signal_reports():
    """Send each signal in separate detailed messages after market hours"""
    global daily_signals, all_generated_signals
    
    all_signals = daily_signals + all_generated_signals
    
    seen_ids = set()
    unique_signals = []
    for signal in all_signals:
        sid = signal.get('signal_id')
        if not sid:
            continue
        if sid not in seen_ids:
            seen_ids.add(sid)
            unique_signals.append(signal)
    
    if not unique_signals:
        send_telegram("üìä END OF DAY REPORT\nNo signals generated today.")
        return
    
    send_telegram(f"üïí END OF DAY SIGNAL REPORT - { (datetime.utcnow()+timedelta(hours=5,minutes=30)).strftime('%d-%b-%Y') }\n"
                  f"üìà Total Signals: {len(unique_signals)}\n"
                  f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
    
    for i, signal in enumerate(unique_signals, 1):
        targets_hit_list = []
        if signal.get('targets_hit', 0) > 0:
            for j in range(signal.get('targets_hit', 0)):
                if j < len(signal.get('targets', [])):
                    targets_hit_list.append(str(signal['targets'][j]))
        
        targets_for_disp = signal.get('targets', [])
        while len(targets_for_disp) < 4:
            targets_for_disp.append('-')
        
        msg = (f"üìä SIGNAL #{i} - {signal.get('index','?')} {signal.get('strike','?')} {signal.get('option_type','?')}\n"
               f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
               f"üìÖ Date: {(datetime.utcnow()+timedelta(hours=5,minutes=30)).strftime('%d-%b-%Y')}\n"
               f"üïí Time: {signal.get('timestamp','?')}\n"
               f"üìà Index: {signal.get('index','?')}\n"
               f"üéØ Strike: {signal.get('strike','?')}\n"
               f"üî∞ Type: {signal.get('option_type','?')}\n"
               f"üè∑Ô∏è Strategy: {signal.get('strategy','?')}\n\n"
               
               f"üí∞ ENTRY: ‚Çπ{signal.get('entry_price','?')}\n"
               f"üéØ TARGETS: {targets_for_disp[0]} // {targets_for_disp[1]} // {targets_for_disp[2]} // {targets_for_disp[3]}\n"
               f"üõë STOP LOSS: ‚Çπ{signal.get('sl','?')}\n\n"
               
               f"üìä PERFORMANCE:\n"
               f"‚Ä¢ Entry Status: {signal.get('entry_status', 'PENDING')}\n"
               f"‚Ä¢ Targets Hit: {signal.get('targets_hit', 0)}/4\n")
        
        if targets_hit_list:
            msg += f"‚Ä¢ Targets Achieved: {', '.join(targets_hit_list)}\n"
        
        msg += (f"‚Ä¢ Max Price Reached: ‚Çπ{signal.get('max_price_reached', signal.get('entry_price','?'))}\n"
                f"‚Ä¢ Final P&L: {signal.get('final_pnl', '0')} points\n\n"
                
                f"‚ö° Fakeout: {'YES' if signal.get('fakeout') else 'NO'}\n"
                f"üìà Index Price at Signal: {signal.get('index_price','?')}\n"
                f"üÜî Signal ID: {signal.get('signal_id','?')}\n"
                f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
        
        send_telegram(msg)
        time.sleep(1)
    
    total_pnl = 0.0
    successful_trades = 0
    for signal in unique_signals:
        pnl_str = signal.get("final_pnl", "0")
        try:
            if isinstance(pnl_str, str) and pnl_str.startswith("+"):
                total_pnl += float(pnl_str[1:])
                successful_trades += 1
            elif isinstance(pnl_str, str) and pnl_str.startswith("-"):
                total_pnl -= float(pnl_str[1:])
        except:
            pass
    
    summary_msg = (f"üìà DAY SUMMARY\n"
                   f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
                   f"‚Ä¢ Total Signals: {len(unique_signals)}\n"
                   f"‚Ä¢ Successful Trades: {successful_trades}\n"
                   f"‚Ä¢ Success Rate: {(successful_trades/len(unique_signals))*100:.1f}%\n"
                   f"‚Ä¢ Total P&L: ‚Çπ{total_pnl:+.2f}\n"
                   f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
    
    send_telegram(summary_msg)
    send_telegram("‚úÖ END OF DAY REPORTS COMPLETED! See you tomorrow at 9:15 AM! üöÄ")

# üö® UPDATED SIGNAL SENDING WITH INSTITUTIONAL FAST TARGETS üö®
def send_signal(index, side, df, fakeout, strategy_key):
    global signal_counter, all_generated_signals
    
    signal_detection_price = float(ensure_series(df["Close"]).iloc[-1])
    strike = round_strike(index, signal_detection_price)
    
    if strike is None:
        send_telegram(f"‚ö†Ô∏è {index}: could not determine strike (price missing). Signal skipped.")
        return
        
    if not can_send_signal(index, strike, side):
        return
        
    symbol = get_option_symbol(index, EXPIRIES[index], strike, side)
    option_price = fetch_option_price(symbol)
    if not option_price: 
        return
    
    entry = round(option_price)
    
    # üö® INSTITUTIONAL FAST TARGETS (15-40 points)
    base_price = signal_detection_price
    
    if side == "CE":
        # For CE: Quick bullish targets
        base_move = max(base_price * INSTITUTIONAL_FVG_TARGET_MULTIPLIER, 15)  # Min 15 points
        targets = [
            round(entry + base_move * 0.8),   # Quick first target
            round(entry + base_move * 1.5),   # Second target  
            round(entry + base_move * 2.2),   # Third target
            round(entry + base_move * 3.0)    # Fourth target
        ]
        sl = round(entry - base_move * INSTITUTIONAL_FVG_SL_MULTIPLIER)
        
    else:  # PE
        # For PE: Quick bearish targets  
        base_move = max(base_price * INSTITUTIONAL_FVG_TARGET_MULTIPLIER, 15)  # Min 15 points
        targets = [
            round(entry + base_move * 0.8),   # Quick first target
            round(entry + base_move * 1.5),   # Second target
            round(entry + base_move * 2.2),   # Third target
            round(entry + base_move * 3.0)    # Fourth target
        ]
        sl = round(entry - base_move * INSTITUTIONAL_FVG_SL_MULTIPLIER)
    
    targets_str = "//".join(str(t) for t in targets) + "++"
    
    strategy_name = STRATEGY_NAMES.get(strategy_key, strategy_key.upper())
    
    signal_id = f"SIG{signal_counter:04d}"
    signal_counter += 1
    
    signal_data = {
        "signal_id": signal_id,
        "timestamp": (datetime.utcnow()+timedelta(hours=5,minutes=30)).strftime("%H:%M:%S"),
        "index": index,
        "strike": strike,
        "option_type": side,
        "strategy": strategy_name,
        "entry_price": entry,
        "targets": targets,
        "sl": sl,
        "fakeout": fakeout,
        "index_price": signal_detection_price,
        "entry_status": "PENDING",
        "targets_hit": 0,
        "max_price_reached": entry,
        "zero_targets": True,
        "no_new_highs": True,
        "final_pnl": "0"
    }
    
    update_signal_tracking(index, strike, side, signal_id)
    all_generated_signals.append(signal_data.copy())
    
    msg = (f"üü¢ {index} {strike} {side}\n"
           f"ABOVE {entry}\n"
           f"TARGETS: {targets_str}\n"
           f"SL: {sl}\n"
           f"FAKEOUT: {'YES' if fakeout else 'NO'}\n"
           f"STRATEGY: {strategy_name}\n"
           f"SIGNAL ID: {signal_id}")
         
    thread_id = send_telegram(msg)
    
    trade_id = f"{symbol}_{int(time.time())}"
    active_trades[trade_id] = {
        "symbol": symbol, 
        "entry": entry, 
        "sl": sl, 
        "targets": targets, 
        "thread": thread_id, 
        "status": "OPEN",
        "index": index,
        "signal_data": signal_data
    }
    
    monitor_price_live(symbol, entry, targets, sl, fakeout, thread_id, strategy_name, signal_data)

# --------- UPDATED TRADE THREAD WITH FAST FVG STRATEGY ---------
def trade_thread(index):
    """Generate signals with institutional FVG strategy"""
    result = analyze_index_signal(index)
    
    if not result:
        return
        
    side, df, fakeout, strategy_key = result
    
    if institutional_flow_confirm(index, side, df):
        send_signal(index, side, df, fakeout, strategy_key)

# --------- FIXED: MAIN LOOP (KEPT INDICES ONLY) ---------
def run_algo_parallel():
    if not is_market_open(): 
        print("‚ùå Market closed - skipping iteration")
        return
        
    if should_stop_trading():
        global STOP_SENT, EOD_REPORT_SENT
        if not STOP_SENT:
            send_telegram("üõë Market closed at 3:30 PM IST - Algorithm stopped")
            STOP_SENT = True
            
        if not EOD_REPORT_SENT:
            time.sleep(15)
            send_telegram("üìä GENERATING COMPULSORY END-OF-DAY REPORT...")
            try:
                send_individual_signal_reports()
            except Exception as e:
                send_telegram(f"‚ö†Ô∏è EOD Report Error, retrying: {str(e)[:100]}")
                time.sleep(10)
                send_individual_signal_reports()
            EOD_REPORT_SENT = True
            send_telegram("‚úÖ TRADING DAY COMPLETED! See you tomorrow at 9:15 AM! üéØ")
            
        return
        
    threads = []
    kept_indices = ["NIFTY", "BANKNIFTY", "SENSEX"]
    
    for index in kept_indices:
        t = threading.Thread(target=trade_thread, args=(index,))
        t.start()
        threads.append(t)
    
    for t in threads: 
        t.join()

# --------- FIXED: START WITH WORKING EOD SYSTEM ---------
STARTED_SENT = False
STOP_SENT = False
MARKET_CLOSED_SENT = False
EOD_REPORT_SENT = False

initialize_strategy_tracking()

while True:
    try:
        utc_now = datetime.utcnow()
        ist_now = utc_now + timedelta(hours=5, minutes=30)
        current_time_ist = ist_now.time()
        current_datetime_ist = ist_now
        
        market_open = is_market_open()
        
        if not market_open:
            if not MARKET_CLOSED_SENT:
                send_telegram("üî¥ Market is currently closed. Algorithm waiting for 9:15 AM...")
                MARKET_CLOSED_SENT = True
                STARTED_SENT = False
                STOP_SENT = False
                EOD_REPORT_SENT = False
            
            if current_time_ist >= dtime(15,30) and current_time_ist <= dtime(16,0) and not EOD_REPORT_SENT:
                send_telegram("üìä GENERATING COMPULSORY END-OF-DAY REPORT...")
                time.sleep(10)
                send_individual_signal_reports()
                EOD_REPORT_SENT = True
                send_telegram("‚úÖ EOD Report completed! Algorithm will resume tomorrow.")
            
            time.sleep(30)
            continue
        
        if not STARTED_SENT:
            send_telegram("üöÄ INSTITUTIONAL FVG MASTER ALGO STARTED\n"
                         "‚úÖ Only NIFTY, BANKNIFTY, SENSEX\n"
                         "‚úÖ INSTITUTIONAL FVG Strategy - FAST MOVES\n"
                         "‚úÖ Quick Targets (15-40 points)\n"
                         "‚úÖ Early FVG Detection\n"
                         "‚úÖ Guaranteed EOD Reports")
            STARTED_SENT = True
            STOP_SENT = False
            MARKET_CLOSED_SENT = False
        
        if should_stop_trading():
            if not STOP_SENT:
                send_telegram("üõë Market closing time reached! Preparing EOD Report...")
                STOP_SENT = True
                STARTED_SENT = False
            
            if not EOD_REPORT_SENT:
                send_telegram("üìä FINALIZING TRADES...")
                time.sleep(20)
                try:
                    send_individual_signal_reports()
                except Exception as e:
                    send_telegram(f"‚ö†Ô∏è EOD Report Error, retrying: {str(e)[:100]}")
                    time.sleep(10)
                    send_individual_signal_reports()
                EOD_REPORT_SENT = True
                send_telegram("‚úÖ TRADING DAY COMPLETED! See you tomorrow at 9:15 AM! üéØ")
            
            time.sleep(60)
            continue
            
        run_algo_parallel()
        time.sleep(30)
        
    except Exception as e:
        error_msg = f"‚ö†Ô∏è Main loop error: {str(e)[:100]}"
        send_telegram(error_msg)
        time.sleep(60)
